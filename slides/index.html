<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Microservice'ing like a Unicorn with Kubernetes, Envoy, and Istio</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style>
			.reveal section img.no-border{
				border: 0px;
				box-shadow: none;
			}

			.reveal p.left-align {
				margin: 20px 100px;
				line-height: 1.3;
				text-align: left;
			}

		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section id="title">
					<h3>Microservice'ing like a unicorn</h3>
					<h4>with Kubernetes, Envoy, and Istio</h4>
					<div align="center">
						<img src="images/unicorn.png"/>
					</div>
					<p>
						<small>Created by <a href="http://twitter.com/christianposta">@christianposta</a> and <a href="https://github.com/christian-posta/istio-workshop/graphs/contributors">contributors</a></small>
					</p>
				</section>
				<section id="agenda">
					<h2>Agenda</h2>
					<ul>
						<li>How did we get here?</li>
						<li>Meet Envoy Proxy</li>
						<li>Hands on with Envoy Proxy</li>
						<li>Meet Istio Service Mesh</li>
						<li>Hands on with Istio Service Mesh</li>
						<li>Additional resources</li>
					</ul>
				</section>

        <section>
          <h2>Source Code Is Here</h2>
          <a href="https://github.com/christian-posta/istio-workshop">https://github.com/christian-posta/istio-workshop</a>
        </section>

				<!--How did we get here------------------------------------------------------------------>
				<!--<section>-->
					<section id="how-we-got-here">
						<h3>How did we get here</h3>

						<aside class="notes">
							Let's talk about some of the drivers of how we got here
						</aside>
					</section>


					<section>
						<h3>so you want a services architecture...</h3>
						<img src="images/openquote.png" class="no-border" height="50" width="75"/>
						<blockquote>"do one thing, do it well"</blockquote>
						<blockquote>"pick right technology for the problem"</blockquote>
						<blockquote>"individual deployment"</blockquote>
					</section>


					<section>
						<h3>Kubernetes to the rescue!</h3>
						<img src="images/little-kube.png" height="300" width="300" class="no-border"/>
					</section>


					<section>
						<p>Kubernetes is a deployment platform; <br/>it does not adequately address service communication</p>
					</section>


					<section>
						<p>the network is <i>not</i> reliable</p>
						<small>
							<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">fallacies of distributed computing</a>
						</small>
						<aside class="notes">
							The network is reliable.
							Latency is zero.
							Bandwidth is infinite.
							The network is secure.
							Topology doesn't change.
							There is one administrator.
							Transport cost is zero.
							The network is homogeneous.
						</aside>
					</section>


					<section>
						<h3>can kubernetes help?</h3>
						<ul>
							<li>DNS based service discovery</li>
							<li>simple L3/4 load balancing</li>
						</ul>
					</section>



					<section>
						<h4>every application must account for</h4>
						<ul>
							<li>unpredictable failure modes</li>
							<li>end-to-end application correctness</li>
							<li>system degradation</li>
							<li>topology changes</li>
							<li>elastic/ephemeral/transient resources</li>
						</ul>
					</section>




					<section>
						<p>so we do things like...</p>
						<ul>
							<li>circuit breaking</li>
							<li>bulkheading</li>
							<li>timeouts</li>
							<li>retries</li>
							<li>service discovery</li>
							<li>client-side loadbalancing</li>
						</ul>
					</section>


					<section>
						<p class="left-align">actually, entire suites of frameworks
							were built to help	developers address these
							resilience concerns
						</p>
						<img src="images/finagle.png" class="no-border"/>
						<img src="images/netflixoss.png" class="no-border"/>

					</section>


					<section>
						<img src="images/netflixoss2.png" class="no-border"/>
						<br/>
						<ul>
							<li>Hystrix</li>
							<li>Zuul</li>
							<li>Ribbon</li>
							<li>Eureka</li>
							<li>Brave/Zipkin</li>
							<li>Spector/Atlas</li>
						</ul>
					</section>



					<section>
						<img src="images/network-commingled.png"/>
					</section>


					<section>
						<h3>but i'm using spring!</h3>
						<ul>
							<li>spring-cloud-netflix-hystrix</li>
							<li>spring-cloud-netflix-zuul</li>
							<li>spring-cloud-netflix-eureka-client</li>
							<li>spring-cloud-netflix-ribbon</li>
							<li>spring-cloud-netflix-atlas</li>
							<li>spring-cloud-netflix-spectator</li>
							<li>spring-cloud-netflix-hystrix-stream</li>
							<li>...</li>
							<li><i>@Enable....150MagicThings</i></li>

						</ul>
					</section>


					<section>
						<h3>but i'm using vert.x</h3>
						<ul>
							<li>vertx-circuit-breaker</li>
							<li>vertx-service-discovery</li>
							<li>vertx-dropwizard-metrics</li>
							<li>vertx-zipkin</li>
							<li>...</li>
						</ul>
					</section>


					<section>
						<h3>but i'm using...</h3>
						<ul>
							<li class="fragment">NodeJS</li>
							<li class="fragment">Go</li>
							<li class="fragment">Python</li>
							<li class="fragment">Ruby</li>
							<li class="fragment">Perl</li>
							<li class="fragment">Get the point!?</li>
						</ul>
					</section>


					<section>
						<p class="left-align">so for every language/framework combination, you need...</p>
						<ul>
							<li>service discovery</li>
							<li>retries</li>
							<li>timeouts</li>
							<li>load balancing</li>
							<li>bulk heading</li>
							<li>circuit breaking</li>
							<li>rate limiting</li>
						</ul>
					</section>


					<section>
						<p class="left-align">so for every language/framework combination, you need...</p>
						<ul>
							<li>adaptive routing</li>
							<li>deadlines</li>
							<li>back pressure</li>
							<li>outlier detection</li>
							<li>health checking</li>
							<li>traffic shaping</li>
							<li>request shadowning</li>
						</ul>
					</section>


					<section>
						<p class="left-align">so for every language/framework combination, you need...</p>
						<ul>
							<li>edge/dmz routing</li>
							<li>surgical / fine / per-request routing</li>
							<li>A/B testing rollout</li>
							<li>dark launches</li>
							<li>fault injection</li>
							<li>stats, metric collection</li>
							<li>observability</li>
						</ul>
					</section>


					<section>
						<h3>drawbacks to library approach</h3>
						<ul>
							<li>need one for each combination language/framework</li>
							<li>need to maintain, upgrade, retire</li>
							<li>classpath/namespace pollution</li>
							<li>increases operational complexity</li>
							<li>force specific languages</li>
							<li>inconsistency</li>
							<li>correctness</li>
						</ul>
					</section>

					<section>
						<p>what if we could implement it once, in one spot, and let any language use it?</p>
						<img src="images/serviceproxy.png"/>
					</section>

				<!--</section>-->

				<!--Meet Envoy Proxy------------------------------------------------------------------>
				<!--<section>-->
					<section id="meet-envoy">
						<h3>Meet Envoy Proxy</h3>
						<div align="center">
							<a href="https://www.envoyproxy.io">https://www.envoyproxy.io</a>
						</div>
						<div align="center">
							<img src="images/envoylogo.png"/>
						</div>
					</section>


					<section>
						<h3>Wait: what is Envoy?</h3>
						<ul>
							<li>service proxy</li>
							<li>written in C++, highly parallel, non-blocking</li>
							<li>L3/4 network filter</li>
							<li>out of the box L7 filters</li>
							<li>HTTP 2, including gRPC</li>
							<li>baked in service discvoery/health checking</li>
							<li>advanced load balancing</li>
							<li>stats, metrics, tracing</li>
							<li>dynamic configuration through xDS</li>

						</ul>

						<div>
							<small>See more here: <br/>
							<a href="https://www.slideshare.net/datawire/lyfts-envoy-from-monolith-to-service-mesh-matt-klein-lyft/12">From Monolith to ServiceMesh - Matt Klein, Lyft</a> </small>
						</div>
					</section>


					<section>
						<img src="images/thatsenvoy.png"/>
					</section>


					<section>
						<h3>Envoy as edge proxy</h3>
						<img src="images/envoyedge.png"/>
					</section>


					<section>
						<h3>Envoy as shared proxy</h3>
						<img src="images/envoyshared.png"/>
					</section>



					<section>
						<h3>Envoy as sidecar proxy</h3>
						<img src="images/envoysidecar.png"/>
					</section>


					<section>
						<h3>sidecar proxy</h3>
						<img src="images/envoyarch.png"/>
					</section>


					<section>
						<h3>Dealing with network traffic</h3>
						<ul>
							<li>zone aware, least request load balancing</li>
							<li>circuit breaking</li>
							<li>outlier detection</li>
							<li>retries, retry policies</li>
							<li>timeout (including budgets)</li>
							<li>traffic shadowing</li>
							<li>rate limiting</li>
							<li>access logging, statistics collection</li>
						</ul>

						<div>
							<small>See more here: <br/>
								<a href="https://www.slideshare.net/datawire/lyfts-envoy-from-monolith-to-service-mesh-matt-klein-lyft/17">From Monolith to ServiceMesh - Matt Klein, Lyft</a> </small>
						</div>
					</section>


				<!--</section>-->

				<!--Hands on with Envoy Proxy------------------------------------------------------------------>
				<!--<section>-->
					<section id="hands-on-envoy">
						<h3>Let's get Hands on </h3>
						<div align="center">
							<a href="https://www.envoyproxy.io">https://www.envoyproxy.io</a>
						</div>
						<div align="center">
							<img src="images/envoylogo.png"/>
						</div>
					</section>


					<section>
						<h3>Prerequisites for hands-on</h3>
						<ul>
							<li>docker cli/client</li>
							<li>access to docker daemon</li>
							<li>ability to mount files into a running docker container (from your workspace/host machine)</li>
							<li>access to multiple terminals (screen, tmux, iterm, etc)</li>
							<li>network connection to <a href="http://hub.docker.io">hub.docker.io</a></li>
						</ul>
						<small>I'm using <a href="https://github.com/kubernetes/minikube">minikube</a>/<a href="https://www.openshift.org/minishift/">minishift</a>. YMMV</small>
					</section>


					<section>
						<h3>Pull some images</h3>
						<blockquote>
							docker pull envoyproxy/envoy
						</blockquote>
						<blockquote>
							docker pull tutum/curl
						</blockquote>
						<blockquote>
							docker pull citizenstig/httpbin
						</blockquote>
					</section>

					<section data-markdown>
						<script type="text/template">
							### Start a simple service

							```
							$  docker run -it --name httpbin --rm citizenstig/httpbin
							```

							### Verify service works

							```
							$  docker run -it --rm --link httpbin tutum/curl \
							curl -X GET http://httpbin:8000/headers

							{
							  "headers": {
							    "Accept": "*/*",
							    "Host": "httpbin:8000",
							    "User-Agent": "curl/7.35.0"
							  }
							}
							```

						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Checkout Envoy!

							```
							$  docker run -it --rm envoyproxy/envoy envoy --help
							```

							### Try running

							```
							$  docker run -it --rm envoyproxy/envoy envoy

							[2017-11-29 23:37:44.748][1][info][main] source/server/server.cc:157]
								initializing epoch 0 (hot restart version=9.200.16384.127)
							[2017-11-29 23:37:44.749][1][critical][main] source/server/server.cc:71]
								error initializing configuration '': unable to read file:


							```

							Damn! No config file!

						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Envoy config file
							```
							{
							  "listeners": "tcp://0.0.0.0:15001",
							  "filters": [ .... ],
							  "admin": {
							    ...
							  },
							  "cluster_manager": {
							    "clusters": {
							       "name": "foo_service",
							       "type": "logical_dns",
							       "lb_type": "round_robin",
							       "hosts": [ ... ]
							    }
							  }
							```

							[See the Envoy docs for more detail](https://www.envoyproxy.io/docs/envoy/latest/intro/intro)
						</script>
					</section>


					<section>
						<h3>Our sample envoy config file</h3>
						<a href="https://github.com/christian-posta/istio-workshop/blob/master/envoy/conf/simple.json" target="_blank">
							https://github.com/christian-posta/istio-workshop/blob/master/envoy/conf/simple.json
						</a>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Let's run with a configuration file

							```
							$  docker run -it --name proxy --link httpbin \
							-v $(pwd)/envoy/conf/simple.json:/etc/simple.json \
							envoyproxy/envoy envoy -c /etc/simple.json

							[2017-11-30 14:05:03.047][1][info][main] source/server/server.cc:157]
							  initializing epoch 0 (hot restart version=9.200.16384.127)
							[2017-11-30 14:05:03.061][1][info][config]
							  source/server/configuration_impl.cc:45] loading 1 listener(s)
							[2017-11-30 14:05:03.070][1][info][config]
							  source/server/configuration_impl.cc:83] loading tracing configuration
							[2017-11-30 14:05:03.070][1][info][config]
							  source/server/configuration_impl.cc:109] loading stats sink configuration
							[2017-11-30 14:05:03.071][1][info][main] source/server/server.cc:348]
							  starting main dispatch loop
							[2017-11-30 14:05:03.075][1][info][upstream]
							  source/common/upstream/cluster_manager_impl.cc:131] cm init: all clusters initialized
							[2017-11-30 14:05:03.075][1][info][main]
							  source/server/server.cc:332] all clusters initialized. initializing init manager
							[2017-11-30 14:05:03.075][1][info][config]
							  source/server/listener_manager_impl.cc:482] all dependencies initialized. starting workers
							```
						</script>
					</section>


					<section>
						<p>now we have a sample service and an envoy proxy configured to forward requests to it</p>
						<img src="images/envoy-httpbin.png"/>
					</section>

					<section data-markdown>
						<script type="text/template">
							### Let's curl the proxy

							```
							$  docker run -it --rm --link proxy tutum/curl \
							curl  -X GET http://proxy:15001/headers
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Response

							note the [X-Request-Id](https://www.envoyproxy.io/docs/envoy/latest/configuration/http_conn_man/headers.html#config-http-conn-man-headers-x-request-id)

							```
							{
							  "headers": {
							    "Accept": "*/*",
							    "Content-Length": "0",
							    "Host": "httpbin",
							    "User-Agent": "curl/7.35.0",
							    "X-Request-Id": "ef264545-4ba6-4865-8172-f9cadcb74e31"
							  }
							}
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Admin stats

							Let's curl the admin stats API

							```
							$  docker run -it --rm --link proxy tutum/curl \
							curl -X GET http://proxy:15000/stats
							```



						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							### Admin stats

							Wow, that's a lot of good info! Let's trim it down:

							```
							$  docker run -it --rm --link proxy tutum/curl \
							curl -X GET http://proxy:15000/stats | grep retry

							cluster.httpbin_service.retry_or_shadow_abandoned: 0
							cluster.httpbin_service.upstream_rq_retry: 0
							cluster.httpbin_service.upstream_rq_retry_overflow: 0
							cluster.httpbin_service.upstream_rq_retry_success: 0
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Retries

							Let's add some retry semantics to `httpbin_service`. Open The `conf/simple.json` file
							and add (or see the `conf/patches` directory):

							```
							"routes": [
							  {
							    "timeout_ms": 0,
							    "prefix": "/",
							    "auto_host_rewrite": true,
							    "cluster": "httpbin_service",
							    "retry_policy": {
							        "retry_on": "5xx",
							        "num_retries": 3
							    }
							}
							```
						</script>
					</section>


					<section>
						<section data-markdown>
							<script type="text/template">
								### Refresh with new config

								Restart our envoy proxy:

								```
								$  docker rm -f proxy
								$  docker run -it --rm --name proxy --link httpbin \
								-v $(pwd)/envoy/conf/simple.json:/etc/simple.json \
								envoyproxy/envoy envoy -c /etc/simple.json
								```
							</script>
						</section>
					</section>


					<section>
						<section data-markdown>
							<script type="text/template">
								### Call an endpoint in error

								Curl the proxy to generate a `500`

								```
								$  docker run -it --rm --link proxy tutum/curl \
								curl -X GET http://proxy:15001/status/500
								```

								Review the envoy admin stats:

								```
								$  docker run -it --rm --link proxy tutum/curl \
								curl -X GET http://proxy:15000/stats | grep retry

								cluster.httpbin_service.retry.upstream_rq_500: 3
								cluster.httpbin_service.retry.upstream_rq_5xx: 3
								cluster.httpbin_service.retry_or_shadow_abandoned: 0
								cluster.httpbin_service.upstream_rq_retry: 3
								cluster.httpbin_service.upstream_rq_retry_overflow: 0
								cluster.httpbin_service.upstream_rq_retry_success: 0
								```
							</script>
						</section>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Additional config: circuit breaking

							```
							"cluster_manager": {
							  "clusters": [
								{
								  "name": "httpbin_service",
								  "hosts": [
									{
									  "url": "tcp://httpbin.org:80"
									}
								  ],
								  "circuit_breakers": {
									"default": {
									  "max_connections": 1,
									  "max_pending_requests": 1,
									  "max_retries": 3
									}
								  },

								 ...

								 }
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Additional config: outlier detection

							```
							{
							  "name": "httpbin_service",
							  ...
							  "circuit_breakers": {
							    "default": {
							      "max_connections": 1,
							      "max_pending_requests": 1,
							      "max_retries": 3
							    }
							  },
							  "outlier_detection" : {
							    "consecutive_5xx": 5,
							    "max_ejection_percent": 100,
							    "interval_ms": 3000
							  }
							}
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Additional config: load balancing

							`lb_type`:

							* round_robin
							* least_request
							* ring_hash
							* random
							* original_dst_lb

							```
							{
							  "name": "httpbin_service",
							    ...
							  "lb_type": "...",
							  "ring_hash_lb_config": { ... }

							}
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Additional config: traffic shifting

							```
							"routes": [
							  {
							    "prefix": "/",
							    "cluster": "helloworld_v1",
							    "runtime": {
							      "key": "routing.traffic_shift.helloworld",
							      "default": 50
							     }
							    },
							  {
							    "prefix": "/",
							    "cluster": "helloworld_v2",
							  }
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Additional config: traffic shifting

							```
							"weighted_clusters": {
							  "runtime_key_prefix" : "routing.traffic_split.helloworld",
							  "clusters" : [
							    { "name" : "helloworld_v1", "weight" : 33 },
							    { "name" : "helloworld_v2", "weight" : 33 },
							    { "name" : "helloworld_v3", "weight" : 34 }
							  ]
							```
						</script>
					</section>



					<section data-markdown>
						<script type="text/template">
							### Envoy resource usage

							```
							$  docker top proxy

							PID      USER         COMMAND
							4997     root         envoy -c /etc/simple.json

							$  docker stats proxy

							CONTAINER    CPU %    MEM USAGE / LIMIT       MEM %
							proxy        0.59%    11.16 MiB / 3.858 GiB   0.28%

							```


						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Compare to Java application with dependencies

							![spring init](images/spring-init-netflix.png)

						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							### Compare to Java application with dependencies

							![spring target listing](images/spring-target-listing.png)

							<small>The netflix libraries make up ~24MB</small>

						</script>
					</section>





					<section data-markdown>
						<script type="text/template">
							### Envoy Discovery (XDS)

							* Listener discovery service (LDS)
							* v1 Route discovery service (RDS)
							* Cluster discovery service (CDS)
							* Service discovery service (SDS)


						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Envoy Discovery (LDS)
							```
							{
							  "listeners": [],
							  "lds": {
							    "cluster": "lds",
							    "refresh_delay_ms": 60000
							  },
							```

						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							### Envoy Discovery (LDS)
							```
							"cluster_manager": {
							  "clusters": [
							    {
							      "name": "lds",
							      "connect_timeout_ms": 10000,
							      "type": "strict_dns",
							      "lb_type": "round_robin",
							      "hosts": [
							        {
							           "url": "tcp://discovery:8080"
							        }
							      ]
							    },
							```

						</script>
						</section>

						<section data-markdown>
							<script type="text/template">
								### Envoy Discovery (SDS)
								```
								"sds": {
								  "cluster": {
								  "name": "sds",
								  "connect_timeout_ms": 10000,
								  "type": "strict_dns",
								  "lb_type": "round_robin",
								  "hosts": [
								    {
								      "url": "tcp://discovery:8080"
								    }
								  ]
								  },
								  "refresh_delay_ms": 60000
								},
								```

							</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### See Envoy docs for more configuration

							[https://www.envoyproxy.io/docs/envoy/latest/intro/intro](https://www.envoyproxy.io/docs/envoy/latest/intro/intro)
						</script>
					</section>
				<!--</section>-->


				<!--Meet Istio service mesh------------------------------------------------------------------>
				<!--<section>-->
					<section id="meet-istio">
						<h3>Meet Istio Service Mesh</h3>
						<div align="center">
							<a href="https://istio.io">https://istio.io</a>
						</div>
						<div align="center">
							<img src="images/istiologo.png"/>
						</div>
					</section>


          <section>
						<h3>How do we configure a fleet of Envoys?</h3>
            <p>Envoy configuration can be verbose and error prone without automation. We need a
            concise model/semantics to manipulate a cluster.</p>
					</section>


          <section>
            <h3>We need cluster semantics</h3>
            <p>Meet <a href="http://istio.io">Istio.io</a> - a control plane for service proxies.</p>
          </section>


        <section>
          <h3>We need cluster semantics</h3>
          <img src="images/istiooverview.png"/>
        </section>

        <section>
          <h3>Cluster semantics?</h3>
          <ul>
            <li>Fleet configuration</li>
            <li>Routing control</li>
            <li>Observability</li>
            <li>Fault inject/chaos testing</li>
            <li>Cluster resilience</li>
            <li>Strong security options</li>
          </ul>
        </section>

        <section>
          <h3>Messages not bytes </h3>
          <p>Istio gives us fine grained control over requests in our application network.</p>
        </section>


        <section>
          <h3>Istio Edge Ingress</h3>
          <img src="images/istioingress.png"/>
        </section>

        <section>
          <h3>Istio control plane</h3>
          <img src="images/istiocontrolplane.png"/>
        </section>




        <section>
          <h3>Istio Pilot</h3>
          <img src="images/istiopilot.png"/>
        </section>


        <section>
          <h3>Istio Mixer</h3>
          <img src="images/istiomixer.png"/>
        </section>

        <section>
          <h3>Istio Observability</h3>
          <img src="images/istioobserve.png"/>
        </section>


        <section>
          <h3>Istio Certificate Authority</h3>
          <img src="images/istioca.png"/>
        </section>


        <section>
          <h3>Istio Mutual TLS</h3>
          <img src="images/istiomtls.png"/>
        </section>



				<!--</section>-->


				<!--Hands on Istio service mesh------------------------------------------------------------------>
				<!--<section>-->
					<section id="hands-on-istio">
						<h3>Let's get hands on</h3>
						<div align="center">
							<a href="https://istio.io">https://istio.io</a>
						</div>
						<div align="center">
							<img src="images/istiologo.png"/>
						</div>
					</section>

				<section>
					<h3>Prerequisites for hands-on</h3>
					<ul>
						<li>kubectl/oc cli client</li>
						<li>Kubernetes 1.7.5 or greater; <br/>OpenShift 3.7 or greater</li>
						<li>admin privileges for cluster</li>
						<li>access to multiple terminals (screen, tmux, iterm, etc)</li>
					</ul>
					<small>I'm using <a href="https://github.com/kubernetes/minikube">minikube</a>/<a href="https://www.openshift.org/minishift/">minishift</a>. YMMV</small>
				</section>

				<section>
					<h3>Additional notes</h3>
					<ul>
						<li>NOTE: use  <i>oc</i> instead of <i>kubectl</i><br/> when on OpenShift</li>
						<li>Istio components will all live in <code>istio-system</code> namespace</li>
						<li>You can add <code>istio-samples</code> for your components/samples</li>
					</ul>
				</section>

        <section data-markdown>
          <script type="text/template">
            ### Install istio

            Custom download script (needed until `0.3.0` is stable) located at `$BASE/istio/installation`:

            ```
            $  cd istio/install
            (istio/install)$  ./downloadIstio.sh
            (istio/install)$  ## kubectl apply -f istio-0.3.0/install/kubernetes/istio.yaml
            ```
            Don't actually do the installation yet. We will take a piece-by-piece approach.

          </script>
        </section>


        <section data-markdown>
          <script type="text/template">
            ### Official istio download
            You can also take a look at the official<br/> [installation instructions from istio.io](https://istio.io/docs/setup/kubernetes/quick-start.html)
          </script>
        </section>



					<section data-markdown>
						<script type="text/template">
							### Istio component deep dive

							Navigate to `$BASE/istio/install/components`

							```
							$  cd istio/install/components
							(istio/install/components)$  ls -l

							-rw-r--r--  1 ceposta  staff   1.5K Dec  4 09:45 istio-ca.yaml
							-rw-r--r--  1 ceposta  staff   2.7K Dec  4 09:40 istio-ingress.yaml
							-rw-r--r--  1 ceposta  staff    18K Dec  4 09:45 istio-mixer.yaml
							-rw-r--r--  1 ceposta  staff   152B Dec  4 09:40 istio-namespace.yaml
							-rw-r--r--  1 ceposta  staff   9.4K Dec  4 14:48 istio-pilot.yaml
							```
						</script>
					</section>



					<section data-markdown>
						<script type="text/template">
							### Set up istio namespace

							Kubernetes:

							```
							$  kubectl apply -f istio-namespace.yaml
							```

							OpenShift:

							```
							$  oc adm policy add-scc-to-user anyuid -z default -n istio-system
							$  oc new-project istio-system
							```

						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Installing Istio Pilot

							Let's take a look at the `istio-pilot.yaml` to understand exactly
							everything we're installing:

							```
							$  cat istio-pilot.yaml
							```

						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							### istio-pilot.yaml: Cluster Roles and bindings

							```
							kind: ClusterRole
							apiVersion: rbac.authorization.k8s.io/v1beta1
							metadata:
							  name: istio-pilot-istio-system
							rules:
							- apiGroups: ["config.istio.io"]
							  resources: ["*"]
							  verbs: ["*"]
							- apiGroups: ["apiextensions.k8s.io"]
							  resources: ["customresourcedefinitions"]
							  verbs: ["*"]
							- apiGroups: ["istio.io"]
							  resources: ["istioconfigs", "istioconfigs.istio.io"]
							  verbs: ["*"]
							- apiGroups: ["extensions"]
							  resources: ["thirdpartyresources", "thirdpartyresources.extensions", "ingresses", "ingresses/status"]
							  verbs: ["*"]
							- apiGroups: [""]
							  resources: ["configmaps"]
							  verbs: ["create", "get", "list", "watch", "update"]
							- apiGroups: [""]
							  resources: ["endpoints", "pods", "services"]
							  verbs: ["get", "list", "watch"]
							- apiGroups: [""]
							  resources: ["namespaces", "nodes", "secrets"]
							  verbs: ["get", "list", "watch"]
							- apiGroups: ["admissionregistration.k8s.io"]
							  resources: ["externaladmissionhookconfigurations"]
							  verbs: ["create", "update", "delete"]
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### istio-pilot.yaml: Custom Resource Definitions

							```
							apiVersion: apiextensions.k8s.io/v1beta1
							kind: CustomResourceDefinition
							metadata:
  							  name: routerules.config.istio.io
							spec:
							  group: config.istio.io
							  names:
							    kind: RouteRule
							    listKind: RouteRuleList
							    plural: routerules
							    singular: routerule
							  scope: Namespaced
							  version: v1alpha2
							```
						</script>
					</section>



					<section data-markdown>
						<script type="text/template">
							### istio-pilot.yaml: Config Map

							```
							apiVersion: v1
							kind: ConfigMap
							metadata:
							  name: istio
							  namespace: istio-system
							data:
							  mesh: |-
								# Uncomment the following line to enable mutual TLS between proxies
								# authPolicy: MUTUAL_TLS
								#
								# Edit this list to avoid using mTLS to connect to these services.
								# Typically, these are control services (e.g kubernetes API server) that don't have Istio sidecar
								# to transparently terminate mTLS authentication.
								mtlsExcludedServices: ["kubernetes.default.svc.cluster.local"]

								# Set the following variable to true to disable policy checks by the Mixer.
								# Note that metrics will still be reported to the Mixer.
								disablePolicyChecks: false
								# Set enableTracing to false to disable request tracing.
								enableTracing: true
								#
								# To disable the mixer completely (including metrics), comment out
								# the following line
								mixerAddress: istio-mixer.istio-system:15004
								# This is the ingress service name, update if you used a different name
								ingressService: istio-ingress
								#
								# Along with discoveryRefreshDelay, this setting determines how
								# frequently should Envoy fetch and update its internal configuration
								# from Istio Pilot. Lower refresh delay results in higher CPU
								# utilization and potential performance loss in exchange for faster
								# convergence. Tweak this value according to your setup.
								rdsRefreshDelay: 1s
								#
								defaultConfig:
									discoveryRefreshDelay: 1s
									#
									# TCP connection timeout between Envoy & the application, and between Envoys.
									connectTimeout: 10s
									#
									### ADVANCED SETTINGS #############
									# Where should envoy's configuration be stored in the istio-proxy container
									configPath: "/etc/istio/proxy"
									binaryPath: "/usr/local/bin/envoy"
									# The pseudo service name used for Envoy.
									serviceCluster: istio-proxy
									# These settings that determine how long an old Envoy
									# process should be kept alive after an occasional reload.
									drainDuration: 45s
									parentShutdownDuration: 1m0s
									#
									# Port where Envoy listens (on local host) for admin commands
									# You can exec into the istio-proxy container in a pod and
									# curl the admin port (curl http://localhost:15000/) to obtain
									# diagnostic information from Envoy. See
									# https://lyft.github.io/envoy/docs/operations/admin.html
									# for more details
									proxyAdminPort: 15000
									#
									# Address where Istio Pilot service is running
									discoveryAddress: istio-pilot.istio-system:15003
									#
									# Zipkin trace collector
									zipkinAddress: zipkin.istio-system:9411
									#
									# Statsd metrics collector. Istio mixer exposes a UDP endpoint
									# to collect and convert statsd metrics into Prometheus metrics.
									statsdUdpAddress: istio-mixer.istio-system:9125
									# Uncomment the following line to enable mutual TLS authentication between
									# sidecars and istio control plane.
									# controlPlaneAuthPolicy: MUTUAL_TLS
							```

						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### istio-pilot.yaml: Service

							```
							apiVersion: v1
							kind: Service
							metadata:
							  name: istio-pilot
							  namespace: istio-system
							  labels:
							  istio: pilot
							spec:
								ports:
								- port: 15003
								  name: http-discovery
								- port: 443
								  name: admission-webhook
								selector:
								  istio: pilot
							```

						</script>
					</section>

				<section data-markdown>
					<script type="text/template">
						### istio-pilot.yaml: Service Account

						```
						apiVersion: v1
						kind: ServiceAccount
						metadata:
							name: istio-pilot-service-account
							namespace: istio-system
						```

					</script>
				</section>


				<section data-markdown>
					<script type="text/template">
						### istio-pilot.yaml: Deployment
						```
						apiVersion: extensions/v1beta1
						kind: Deployment
						metadata:
						  name: istio-pilot
						  namespace: istio-system
						  annotations:
						    sidecar.istio.io/inject: "false"
						spec:
						  replicas: 1
						  template:
						  metadata:
						    labels:
							  istio: pilot
						  spec:
						    serviceAccountName: istio-pilot-service-account
							containers:
							- name: discovery
							  image: docker.io/istio/pilot:0.3.0
							  imagePullPolicy: IfNotPresent
							  args: ["discovery", "-v", "2", "--admission-service", "istio-pilot-external"]
						      ports:
							  - containerPort: 8080
							  - containerPort: 443
							  env:
						      - name: POD_NAME
								valueFrom:
							      fieldRef:
									apiVersion: v1
									fieldPath: metadata.name
							  - name: POD_NAMESPACE
								valueFrom:
							      fieldRef:
									apiVersion: v1
									fieldPath: metadata.namespace
							  volumeMounts:
							  - name: config-volume
								mountPath: /etc/istio/config
							- name: istio-proxy
							  image: docker.io/istio/proxy_debug:0.3.0
							  imagePullPolicy: IfNotPresent
							  ports:
							  - containerPort: 15003
							  args:
							  - proxy
							  - pilot
							  - -v
							  - "2"
							  - --discoveryAddress
							  - istio-pilot:15003
							  - --controlPlaneAuthPolicy
							  - NONE #--controlPlaneAuthPolicy
							  - --customConfigFile
							  - /etc/istio/proxy/envoy_pilot.json
							  volumeMounts:
							  - name: istio-certs
								mountPath: /etc/certs
								readOnly: true
							  volumes:
							  - name: config-volume
								configMap:
								name: istio
							  - name: istio-certs
								secret:
							      secretName: istio.istio-pilot-service-account
								  optional: true
						```

					</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Installing Istio Pilot

							Let's install it...

							```
							$  kubectl apply -f istio-pilot.yaml

							clusterrole "istio-pilot-istio-system" configured
							clusterrole "istio-initializer-istio-system" configured
							clusterrole "istio-sidecar-istio-system" configured
							clusterrolebinding "istio-pilot-admin-role-binding-istio-system" configured
							clusterrolebinding "istio-initializer-admin-role-binding-istio-system" configured
							clusterrolebinding "istio-sidecar-role-binding-istio-system" configured
							customresourcedefinition "destinationpolicies.config.istio.io" configured
							customresourcedefinition "egressrules.config.istio.io" configured
							customresourcedefinition "routerules.config.istio.io" configured
							configmap "istio" created
							service "istio-pilot" created
							serviceaccount "istio-pilot-service-account" created
							deployment "istio-pilot" created
							```

						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### We have Pilot!

							```
							$  kubectl get pods -n istio-system

							NAME                       READY   STATUS    RESTARTS   AGE
							istio-pilot-036077-q4f68   2/2     Running   0          1m

							```
						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							### Interact with pilot: xDS

							```
							$  kubectl run -i --rm --restart=Never dummy --image=tutum/curl:alpine \
							-n istio-system --command \
							-- curl -vvvv 'http://istio-pilot:15003/v1/registration'
							```

							Returns services and service endpoints
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Pilot and CRD

							![Pilot diagram](images/pilotcrd.png)


						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Let's take a look at a service

							Navigate to `$BASE/istio/install/istio-0.3.0/samples/httpbin`

							```
              $  cd istio/install/istio-0.3.0/samples/httpbin
							$  cat httpbin.yaml

							apiVersion: v1
							kind: Service
							metadata:
							  name: httpbin
							  labels:
							    app: httpbin
							spec:
							  ports:
							  - name: http
							    port: 8000
							    selector:
							      app: httpbin
							---
							apiVersion: extensions/v1beta1
							kind: Deployment
							metadata:
							  name: httpbin
							spec:
							  replicas: 1
							  template:
							    metadata:
							      labels:
							      app: httpbin
							  spec:
							    containers:
							    - image: docker.io/citizenstig/httpbin
							      imagePullPolicy: IfNotPresent
							      name: httpbin
							      ports:
							      - containerPort: 8000
							```

						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Let's decorate our service with sidecar

							```
							$	 ../../bin/istioctl kube-inject -f httpbin.yaml

							apiVersion: extensions/v1beta1
							kind: Deployment
							metadata:
							  annotations:
							    sidecar.istio.io/status: injected-version-root@24c944bda24b-0.3.0-24ec6a3ac3a1d592d1873d2d8198278a849b8301
							  creationTimestamp: null
							  name: httpbin
							spec:
							  replicas: 1
							  strategy: {}
							  template:
							    metadata:
							      annotations:
							        sidecar.istio.io/status: injected-version-root@24c944bda24b-0.3.0-24ec6a3ac3a1d592d1873d2d8198278a849b8301
							    creationTimestamp: null
							    labels:
							      app: httpbin
							  spec:
							    containers:
							      - image: docker.io/citizenstig/httpbin
							      imagePullPolicy: IfNotPresent
							      name: httpbin
							      ports:
							      - containerPort: 8000
							        resources: {}
							        - args:
							          - proxy
							          - sidecar
							          - -v
							          - "2"
							          - --configPath
							          - /etc/istio/proxy
							          - --binaryPath
							          - /usr/local/bin/envoy
							          - --serviceCluster
							          - httpbin
							          - --drainDuration
							          - 45s
							          - --parentShutdownDuration
							          - 1m0s
							          - --discoveryAddress
							          - istio-pilot.istio-system:15003
							          - --discoveryRefreshDelay
							          - 1s
							          - --zipkinAddress
							          - zipkin.istio-system:9411
							          - --connectTimeout
							          - 10s
							          - --statsdUdpAddress
							          - istio-mixer.istio-system:9125
							          - --proxyAdminPort
							          - "15000"
							          - --controlPlaneAuthPolicy
							          - NONE
							    env:
							      - name: POD_NAME
							        valueFrom:
							          fieldRef:
							            fieldPath: metadata.name
							      - name: POD_NAMESPACE
							        valueFrom:
							          fieldRef:
							            fieldPath: metadata.namespace
							      - name: INSTANCE_IP
							        valueFrom:
							          fieldRef:
							            fieldPath: status.podIP
							    image: docker.io/istio/proxy_debug:0.3.0
							    imagePullPolicy: IfNotPresent
							    name: istio-proxy
							    resources: {}
							    securityContext:
							      privileged: true
							      readOnlyRootFilesystem: false
							      runAsUser: 1337
							    volumeMounts:
							    - mountPath: /etc/istio/proxy
							      name: istio-envoy
							    - mountPath: /etc/certs/
							      name: istio-certs
							      readOnly: true
							  initContainers:
							  - args:
							    - -p
							    - "15001"
							    - -u
							    - "1337"
							    image: docker.io/istio/proxy_init:0.3.0
							    imagePullPolicy: IfNotPresent
							    name: istio-init
							    resources: {}
							      securityContext:
							        capabilities:
							          add:
							          - NET_ADMIN
							          privileged: true
							  - args:
							    - -c
							    - sysctl -w kernel.core_pattern=/etc/istio/proxy/core.%e.%p.%t && ulimit -c
							      unlimited
							    command:
							    - /bin/sh
							    image: alpine
							    imagePullPolicy: IfNotPresent
							    name: enable-core-dump
							    resources: {}
							    securityContext:
							      privileged: true
							    volumes:
							    - emptyDir:
							      medium: Memory
							      sizeLimit: "0"
							      name: istio-envoy
							    - name: istio-certs
							      secret:
							        optional: true
							        secretName: istio.default
							   status: {}
							```
						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Deploy our service

							We'll deploy our service, but exclude the mixer stuff for now
							as we just have pilot deployed.

							```
							$  ../../bin/istioctl kube-inject -f httpbin.yaml \
							| sed -E  '/mixer|stats/d' \
							| kubectl apply -f -
							```

							Note, on OpenShift, you'll need to enable permissions in your
							namespace/project for the proxy (we'll come back to that):

							```
							$  oc adm policy add-scc-to-user privileged -z default -n <namespace-name>
							```

						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Do we see our service in Pilot's SDS?

							```
							$  kubectl run -i --rm --restart=Never dummy --image=tutum/curl:alpine \
							-n istio-system --command -- \
							curl -vvvv 'http://istio-pilot:15003/v1/registration/httpbin.istio-samples.svc.cluster.local|http'

							{
							  "hosts": [
							    {
							      "ip_address": "172.17.0.3",
							      "port": 8000
							    }
							  ]
							}
							```


						</script>
					</section>


					<section data-markdown>
						<script type="text/template">
							### Our service now has an envoy sidecar:

							```
							$  kubectl run -i --rm --restart=Never dummy --image=tutum/curl:alpine \
							--command -- curl -vvvv http://httpbin:8000/headers

							{
							  "headers": {
								  "Accept": "*/*",
								  "Content-Length": "0",
								  "Host": "httpbin:8000",
								  "User-Agent": "curl/7.54.0",
								  "X-B3-Sampled": "1",
								  "X-B3-Spanid": "8d9cd38dc2ac623e",
								  "X-B3-Traceid": "8d9cd38dc2ac623e",
								  "X-Istio-Attributes": "ChMKCXNvdXJjZS5pcBIGMgSsEQADCkIKCnNvdXJjZS51aWQSNBIya3ViZXJuZXRlczovL2h0dHBiaW4tODY1OTU4MjU5LWs4cWZkLmlzdGlvLXNhbXBsZXM=",
								  "X-Ot-Span-Context": "8d9cd38dc2ac623e;8d9cd38dc2ac623e;0000000000000000",
								  "X-Request-Id": "75764196-ab89-9937-887f-bcbb3e7bf34b"
							  }
							}

							```

              Note all of the new headers!


						</script>
					</section>


                    <section data-markdown>
                        <script type="text/template">
                            ### Istio proxy

                            Let's poke around the istio proxy (based on envoy).
                            Type the following (substitute the
                            httpbin pod name for your pod name):

                            ```
                            $  kubectl exec -it httpbin-865958259-k8qfd -c istio-proxy  sh

                            (proxy)$  ps aux

                            (proxy)$  ls -l /etc/istio/proxy

                            (proxy)$  cat /etc/istio/proxy/envoy-rev0.json
                            ```

                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ### Istio proxy

                            Istio installs iptable rules to route all pod traffic
                            to the envoy listener on 15001.
                            Let's see what rules the istio-proxy thinks it has:

                            ```
                            (proxy)$  sudo su -
                            (proxy)$  iptables -t nat -L
                            ```

                            Note, these rules get set up as part of the init container, and the iptables rules
                            [are here in the prep scripts](https://github.com/istio/istio/blob/master/pilot/docker/prepare_proxy.sh)

                        </script>
                    </section>


                    <section data-markdown>
                        <script type="text/template">
                            ### Istio proxy

                            Let's ask the local envoy proxy what it knows about its
                            listeners, routes, clusters, and info (remember it got :
                            this from xDS from Pilot?)

                            ```
                            (proxy)$  curl localhost:15000
                            (proxy)$  curl localhost:15000/listeners
                            (proxy)$  curl localhost:15000/routes
                            (proxy)$  curl localhost:15000/clusters
                            (proxy)$  curl localhost:15000/server_info
                            ```

                            See the [admin v1 REST interface for more details](https://www.envoyproxy.io/docs/envoy/v1.5.0/operations/admin)

                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ### Istio Ingress

                            Navigate to `$BASE/istio/install/components`. We'll install the ingress
                            but remove the link to mixer since we still don't have that.

                            ```
                            $  cd istio/install/components
                            $  cat istio-ingress.yaml | sed -E '/mixer|stats/d' | kubectl apply -f -

                            clusterrolebinding "istio-ingress-admin-role-binding-istio-system" created
                            service "istio-ingress" created
                            serviceaccount "istio-ingress-service-account" created
                            deployment "istio-ingress" created

                            ```
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ### Ingress gets exposed via Loadbalancer

                            ```
                            $  kubectl get svc istio-ingress -n istio-system -o yaml
                            apiVersion: v1
                            kind: Service
                            metadata:
                              creationTimestamp: 2017-12-07T18:04:44Z
                              labels:
                                istio: ingress
                              name: istio-ingress
                            spec:
                              type: LoadBalancer
                              clusterIP: 172.30.223.5
                              externalIPs:
                              - 172.29.200.58
                              externalTrafficPolicy: Cluster
                              ports:
                              - name: http
                                nodePort: 31250
                                port: 80
                                protocol: TCP
                                targetPort: 80
                              - name: https
                                nodePort: 31658
                                port: 443
                                protocol: TCP
                                targetPort: 443
                              selector:
                                istio: ingress
                              sessionAffinity: None

                            ```
                        </script>
                    </section>

                    <section data-markdown>
                      <script type="text/template">
                        ### Ingress is just a simple Istio proxy

                        The actual k8s ingress controller lives in *pilot*.
                        `istio-ingress` is really just the istio proxy that is
                        programmed by Envoy routes.
                      </script>
                    </section>
                  <section data-markdown>
                    <script type="text/template">
                      ### Let's create an ingress resource for httpbin

                      ```
                      $  cd istio/ing
                      $  kubectl apply -f httpbin-ingress.yaml
                      ```

                      Now we should have an ingress resource that routes ingress traffic
                      to httpbin:

                      ```
                      $ kubectl get ing

                      NAME              HOSTS     ADDRESS         PORTS     AGE
                      gateway   *         172.29.200.58   80        11m
                      ```
                    </script>
                  </section>

                  <section data-markdown>
                    <script type="text/template">
                      ### Now let's hit httpbin from outside the cluster

                      We need to find the NodePort for our LoadBalancer (if it's not on a cloud
                      that automatically supports LoadBalancer):

                      ```
                      $  kubectl get svc/istio-ingress -n istio-system -o yaml \
                      | grep -i nodeport | head -n 1 | awk '{ print $2 }'

                      31250
                      ```

                      ```
                      $  curl $(minishift ip):31250/headers

                      {
                        "headers": {
                          "Accept": "*/*",
                          "Content-Length": "0",
                          "Host": "192.168.64.34:31250",
                          "User-Agent": "curl/7.43.0",
                          "X-B3-Sampled": "1",
                          "X-B3-Spanid": "39a288ace1fe994f",
                          "X-B3-Traceid": "39a288ace1fe994f",
                          "X-Envoy-Internal": "true",
                          "X-Istio-Attributes": "ChMKCXNvdXJjZS5pcBIGMgSsEQADCkIKCnNvdXJjZS51aWQSNBIya3ViZXJuZXRlczovL2h0dHBiaW4tODY1OTU4MjU5LWs4cWZkLmlzdGlvLXNhbXBsZXM=",
                          "X-Ot-Span-Context": "39a288ace1fe994f;39a288ace1fe994f;0000000000000000",
                          "X-Request-Id": "1e7b9738-974f-92f0-859e-c5cfb006c7c1"
                        }
                      }
                      ```
                      <small>you'll have to figure out what's the public IP of your cluster</small>
                      if not using minikube/minishift
                    </script>
                  </section>

                  <section data-markdown>
                    <script type="text/template">
                      ### What does the envoy route config for ingress look like?
                      This is an exercise for the user :) Hint: log into the ingress and query the admin
                      REST interface at `http://localhost:15000` :)
                    </script>
                  </section>

                  <section data-markdown>
                    <script type="text/template">
                      ### Istio Mixer

                      Navigate to `$BASE/istio/install`. We will install some additional
                      components to go along with mixer.

                      ```
                      $  cd istio/install
                      $  kubectl apply -f istio-0.3.0/install/kubernetes/addons/zipkin.yaml
                      $  kubectl apply -f istio-0.3.0/install/kubernetes/addons/prometheus.yaml
                      $  kubectl apply -f istio-0.3.0/install/kubernetes/addons/grafana.yaml

                      ```
                    </script>
                  </section>

                  <section data-markdown>
                    <script type="text/template">
                      ### Istio Mixer

                      Take a look at the mixer yaml and then install it:

                      ```
                      $  cat components/istio-mixer.yaml
                      $  kubectl apply -f components/istio-mixer.yaml

                      ```

                      In previous steps, we commented out the mixer config (from pilot and ingress).
                      Let's re-install those:

                      ```
                      $  kubectl apply -f components/istio-pilot.yaml
                      $  kubectl apply -f components/istio-ingress.yaml
                      ```
                    </script>
                  </section>

                  <section data-markdown>
                    <script type="text/template">
                      ### Istio Mixer

                      To verify the components were installed correctly,
                      get the publicly accessible URLs using the `$BASE/istio/bin/get-urls.sh` script.
                      If using openshift, just create routes for these services like:

                      ```
                      $  oc expose svc/zipkin
                      $  oc expose svc/grafana

                      $  oc get route

                      NAME      HOST/PORT                                   PATH  SERVICES   PORT
                      grafana   grafana-istio-system.192.168.64.34.nip.io         grafana    http
                      zipkin    zipkin-istio-system.192.168.64.34.nip.io          zipkin     http

                      ```

                      Navigate to one of these openshift routes and verify installation.
                    </script>
                    </section>


                    <section data-markdown>
                      <script type="text/template">
                        ### Istio Mixer

                        Envoy proxies call Mixer to Check and Report. Let's open up some mixer ports
                        to get an idea what calls its seeing:

                        ```
                        $  kubectl  port-forward -n istio-system istio-mixer-333075648-rrr2w  9093

                        ```

                        Navigate to [http://localhost:9093/metrics](http://localhost:9093/metrics)
                        <br/>
                        Do a search for `grpc_server_handled_total`

                      </script>
                  </section>

                    <section data-markdown>
                      <script type="text/template">
                        ### Exercise Mixer

                        Let's call the httpbin service (through ingress or openshift route).
                        Then navigate back to the Mixer stats page and search for `grpc_server_handled_total`
                        Should see something similar to this:

                        ```
                        # HELP grpc_server_handled_total Total number of RPCs completed
                        # on the server, regardless of success or failure.
                        # TYPE grpc_server_handled_total counter
                        grpc_server_handled_total{grpc_code="Internal",grpc_method="Report",grpc_service="istio.mixer.v1.Mixer",grpc_type="unary"} 5
                        grpc_server_handled_total{grpc_code="OK",grpc_method="Check",grpc_service="istio.mixer.v1.Mixer",grpc_type="unary"} 49

                        ```

                      </script>
                    </section>

                    <section data-markdown>
                      <script type="text/template">
                        ### Exercise Mixer

                        Let's imitate a mixer call and try send a report.
                        Navigate to `$BASE/istio/bin/<platform>`

                        First open the Mixer grpc port:
                        ```
                        $  kubectl  port-forward -n istio-system istio-mixer-333075648-rrr2w  9091
                        ```

                        Let's use the `mixc` cli to send a report:
                        ```
                        $  ./mixc report -a target.service=httpbin.istio-samples.svc.cluster.local \
                        --timestamp_attributes request.time=0001-01-01T00:00:00Z

                        Report RPC returned OK
                        ```

                        Now go search Mixer stats page again. Should see our new query. 

                      </script>
                      </section>
                      <section data-markdown id="istio-data-model">
                      	<script type="text/template">
													### Putting it all together
													
													Istio high-level model:

													* Route rules
													* Destination policy
													* Egress rules
													* Mixer rules
												</script>
												<!-- https://istio.io/docs/concepts/traffic-management/rules-configuration.html -->
                      </section>
        <section data-markdown>
          <script type="text/template">
            ### Deploy bookinfo

            Navigate to $BASE/istio and run the following:

            ```
            $  istioctl kube-inject -f bookinfo/bookinfo.yaml | kubectl apply -f -
            ```

            If on OpenShift, you'll need to allow some relaxed permissions because some of the services
            write logs to `/opt/*`

            ```
            $  oc adm policy add-scc-to-user anyuid -z default -n istio-samples
            ```

            You can then use Kubernetes ingress or OpenShift routes to expose the `productpage` svc:

            ```
            $  ./bin/get-ingress-url.sh
            ```

          </script>
          <!-- https://istio.io/docs/concepts/traffic-management/rules-configuration.html -->
        </section>

        <section data-markdown>
					<script type="text/template">
						### Route rules

						![service model](images/istio-svc-model.png)
          </script>
					<!-- https://istio.io/docs/concepts/traffic-management/rules-configuration.html -->
				</section>

        <section data-markdown>
          <script type="text/template">
            ### Force all traffic to v1

            ```
            apiVersion: config.istio.io/v1alpha2
            kind: RouteRule
            metadata:
              name: productpage-default
            spec:
            ## Used by services inside the Kubernetes cluster
              destination:
                name: productpage
              precedence: 1
              route:
              - labels:
                  version: v1
            ```

          </script>
          <!-- https://istio.io/docs/concepts/traffic-management/rules-configuration.html -->
        </section>

        <section data-markdown>
          <script type="text/template">
            ### Force all traffic to v1


            ```
            $  istioctl create -f bookinfo/route-rules/route-rule-all-v1.yaml -n istio-samples

            Created config route-rule//productpage-default at revision 420820
            Created config route-rule//reviews-default at revision 420821
            Created config route-rule//ratings-default at revision 420822
            Created config route-rule//details-default at revision 420823
            ```

            Note the `istioctl` command is not namespace aware -- need to be explicit!

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ### Check routing rules:

            ```
            $  # this gets all route rules across namespaces
            $  istioctl get routerules
            $  # can use plain kubectl also (namespace specific)
            $  kubectl get routerules

            ```

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ### Deploy reviews v2

            ```
            $  istioctl kube-inject -f bookinfo/reviews-deployment-v2.yaml \
            | kubectl apply -f -

            deployment "reviews-v2" created

            ```

            Try hitting the reviews API (substitute for your ingress endpoint or OpenShift Route)

            ```
            $  curl 192.168.64.34:31250/api/v1/products/0/reviews
            {
              "id": "0",
              "reviews": [
                {
                  "reviewer": "Reviewer1",
                  "text": "An extremely entertaining play by Shakespeare. The slapstick humour is refreshing!"
                },
                {
                  "reviewer": "Reviewer2",
                  "text": "Absolutely fun and entertaining. The play lacks thematic depth when compared to other plays by Shakespeare."
                }
              ]
            }
            ```

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ### Dark launch reviews v2

            ```
            $  istioctl create -n istio-samples -f \
            bookinfo/route-rules/route-rule-reviews-dark-v2.yaml

            Updated config route-rule/istio-samples/reviews-test-v2 to revision 424459

            ```

            Try hitting the reviews API and pass in a cookie param:

            ```
            $  curl --cookie "user=jason" 192.168.64.34:31250/api/v1/products/0/reviews
            {
              "id": "0",
              "reviews": [
                {
                  "rating": { "color": "black", "stars": 5 },
                  "reviewer": "Reviewer1",
                  "text": "An extremely entertaining play by Shakespeare. The slapstick humour is refreshing!"
                },
                {
                  "rating": { "color": "black", "stars": 4 },
                  "reviewer": "Reviewer2",
                  "text": "Absolutely fun and entertaining. The play lacks thematic depth when compared to other plays by Shakespeare."
                }
              ]
            }
            ```

          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ### Where do these routing rules live?

            In Pilot RDS services. Log into the `productpage` pod's proxy and
            let's take a look at the routes;


            ```
            $  kubectl exec -it productpage-v1-3581918468-b9lws -c istio-proxy sh
            $>  curl localhost:15000/routes

            ```
            In the response we should see an entry for:

            ```
            {"name":"reviews.istio-samples.svc.cluster.local|http","domains":["reviews:9080","reviews","reviews
            .istio-samples:9080","reviews.istio-samples","reviews.istio-samples.svc:9080","reviews.istio-samples.svc",
            "reviews.istio-samples.svc.cluster:9080","reviews.istio-samples.svc.cluster","reviews.istio-samples.svc
            .cluster.local:9080","reviews.istio-samples.svc.cluster.local","172.30.160.190:9080","172.30.160.190"],
            "routes":[{"match":{"prefix":"/","headers":[{"name":"cookie","value":"^(.*?;)?(user=jason)(;.*)?$",
            "regex":true}]},"route":{"cluster":"out.reviews.istio-samples.svc.cluster.local|http|version=v2",
            "timeout":"0s"},"decorator":{"operation":"reviews-test-v2"}},{"match":
            {"prefix":"/"},"route":{"cluster":"out.reviews.istio-samples.svc.cluster.local|http|version=v1",
            "timeout":"0s"},"decorator":{"operation":"reviews-default"}
            ```

            Note the routing based on Cookie params.


          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ### Where do we go from here?

            This workshop is a work in progress. [Please follow along for updates](http://twitter.com/christianposta).
            Next topics to add:

            * More complicated routing
            * Chaos testing
            * Observability/tracing
            * Mixer adapters/plugins


          </script>
        </section>

        <section data-markdown id="additional-resources">
          <script type="text/template">
            ### Additional resources

            * [Istio on OpenShift via Veer Muchandi](https://github.com/VeerMuchandi/istio-on-openshift)
            * [Envoy resilience examples](http://blog.christianposta.com/microservices/00-microservices-patterns-with-envoy-proxy-series/)
            * [Istio and Kubernetes via Zach Butcher, et. al.](https://github.com/ZackButcher/istio-workshop)
            * [Bookinfo from http://istio.io](https://istio.io/docs/tasks/traffic-management/request-routing.html)

          </script>
        </section>




			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: true,
    			progress: true,
    			history: true,
    			// center: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
